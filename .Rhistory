DEM_rs <- DEM_raw %>%
st_warp(OMI_raw[,,,1] %>% split("date") ,
use_gdal = TRUE , method = "bilinear") %>%
setNames("DEM")
# default: nearest neighbor resampling
ERA_rsNN <- ERA_raw %>%
st_warp(dest = OMI_raw)
{ # separate the resampled CAMS data into sub-datasets(8*2=16) to have the same dimension as OMI
subset.ERA_hour <- ERA_rsNN %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
# 7 attributes: "u10" "v10" "t2m" "blh" "sp"  "tcc" "tp"
subset.ERA_var <- ERA_rsNN %>% names()
# subset into 16 3D arrays
for(h in subset.ERA_hour){
for(v in subset.ERA_var){
# subset the raw dataset: at hour h and for variable (attribute) v
ERA_rs_temp <- ERA_rsNN %>%
filter(hour(time) == h) %>%
select(all_of(v)) %>%
setNames(v) %>%
# # dimension: date
st_set_dimensions(3 ,
values = as_date(st_get_dimension_values(. , 3)) ,
names = "date")
# name the object name as ERA_rs_{Variable}_{Hour}
assign(paste0("ERA_rs_" , v , "_" , h) , ERA_rs_temp)
rm(ERA_rs_temp)
}
}
# clean intermediate objects of the loop
rm(h , v , subset.ERA_hour , subset.ERA_var)
}
# convert u,v wind components to wind speed, wind direction
{
subset.ERA_hour <- ERA_raw %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
for(h in subset.ERA_hour){
ERA_rs_wind_temp <- c(
get(paste0("ERA_rs_u10_" , h)) ,
get(paste0("ERA_rs_v10_" , h))
) %>%
# wd = atan2(-u10,-v10)
# ws = sqrt(u10^2 + v10^2)
transmute(wd = atan2(-u10 , -v10) ,
ws = sqrt(u10^2+v10^2))
# name the object name as CAMS_rs_wind_{Hour}
assign(paste0("ERA_rs_wind_" , h) , ERA_rs_wind_temp)
}
# clean
rm(h , subset.ERA_hour , ERA_rs_wind_temp)
}
# =====================================
# data preparation
# combining spatial and spatialtemporal predictor sets
# =====================================
# spatialtemporal datasets: 3D (x,y,date) + attributes --------------------------------
spatialtemporal <- c(
# OMI
OMI_raw %>%
setNames("OMI_NO2") ,
# CAMS NO2
c(CAMS_rs_tcno2_0 , CAMS_rs_tcno2_3 , CAMS_rs_tcno2_6 , CAMS_rs_tcno2_9 ,
CAMS_rs_tcno2_12 , CAMS_rs_tcno2_15 , CAMS_rs_tcno2_18 , CAMS_rs_tcno2_21) %>%
setNames(c("CAMS_NO2_00" , "CAMS_NO2_03" , "CAMS_NO2_06" , "CAMS_NO2_09" ,
"CAMS_NO2_12" , "CAMS_NO2_15" , "CAMS_NO2_18" , "CAMS_NO2_21")) ,
# CAMS NO
c(CAMS_rs_tc_no_0 , CAMS_rs_tc_no_3 , CAMS_rs_tc_no_6 , CAMS_rs_tc_no_9 ,
CAMS_rs_tc_no_12 , CAMS_rs_tc_no_15 , CAMS_rs_tc_no_18 , CAMS_rs_tc_no_21) %>%
setNames(c("CAMS_NO_00" , "CAMS_NO_03" , "CAMS_NO_06" , "CAMS_NO_09" ,
"CAMS_NO_12" , "CAMS_NO_15" , "CAMS_NO_18" , "CAMS_NO_21")) ,
# ERA blh
c(ERA_rs_blh_0 , ERA_rs_blh_3 , ERA_rs_blh_6 , ERA_rs_blh_9 ,
ERA_rs_blh_12 , ERA_rs_blh_15 , ERA_rs_blh_18 , ERA_rs_blh_21) %>%
setNames(c("blh_00" , "blh_03" , "blh_06" , "blh_09" ,
"blh_12" , "blh_15" , "blh_18" , "blh_21")) ,
# ERA temperature
c(ERA_rs_t2m_0 , ERA_rs_t2m_3 , ERA_rs_t2m_6 , ERA_rs_t2m_9 ,
ERA_rs_t2m_12 , ERA_rs_t2m_15 , ERA_rs_t2m_18 , ERA_rs_t2m_21) %>%
setNames(c("t2m_00" , "t2m_03" , "t2m_06" , "t2m_09" ,
"t2m_12" , "t2m_15" , "t2m_18" , "t2m_21")) ,
# ERA surface pressure
c(ERA_rs_sp_0 , ERA_rs_sp_3 , ERA_rs_sp_6 , ERA_rs_sp_9 ,
ERA_rs_sp_12 , ERA_rs_sp_15 , ERA_rs_sp_18 , ERA_rs_sp_21) %>%
setNames(c("sp_00" , "sp_03" , "sp_06" , "sp_09" ,
"sp_12" , "sp_15" , "sp_18" , "sp_21")) ,
# ERA total cloud cover
c(ERA_rs_tcc_0 , ERA_rs_tcc_3 , ERA_rs_tcc_6 , ERA_rs_tcc_9 ,
ERA_rs_tcc_12 , ERA_rs_tcc_15 , ERA_rs_tcc_18 , ERA_rs_tcc_21) %>%
setNames(c("tcc_00" , "tcc_03" , "tcc_06" , "tcc_09" ,
"tcc_12" , "tcc_15" , "tcc_18" , "tcc_21")) ,
# ERA total precipitation
c(ERA_rs_tp_0 , ERA_rs_tp_3 , ERA_rs_tp_6 , ERA_rs_tp_9 ,
ERA_rs_tp_12 , ERA_rs_tp_15 , ERA_rs_tp_18 , ERA_rs_tp_21) %>%
setNames(c("tp_00" , "tp_03" , "tp_06" , "tp_09" ,
"tp_12" , "tp_15" , "tp_18" , "tp_21")) ,
# ERA wind
c(ERA_rs_wind_0 , ERA_rs_wind_3 , ERA_rs_wind_6 , ERA_rs_wind_9 ,
ERA_rs_wind_12 , ERA_rs_wind_15 , ERA_rs_wind_18 , ERA_rs_wind_21) %>%
setNames(c("wd_00", "ws_00", "wd_03", "ws_03", "wd_06", "ws_06", "wd_09", "ws_09",
"wd_12", "ws_12", "wd_15", "ws_15", "wd_18", "ws_18", "wd_21", "ws_21"))
) %>%
st_set_dimensions(3 , values = yday(st_get_dimension_values(. , 3)) , names = "DOY")
# spatial datasets: 2D (x,y) + attributes --------------------------------
spatial <- c(
# DEM
DEM_rs
)
# input data frame for the imputation model --------------------------------
imputation_df <- spatialtemporal %>%
as.data.frame() %>%
mutate(across(everything() , as.numeric)) %>%
left_join(spatial %>% as.data.frame() ,
by = c("x" , "y")) %>%
# Some pixels are outside of the AOI and are always NA,
# should be removed from the data.frame so that it wouldn’t be counted.
full_join(
# AOI mask in raster form
AOI %>%
st_rasterize(template = spatial) %>%
# is.AOI: a column with TRUE/FALSE
mutate(is.AOI = ifelse(is.na(FID) , FALSE , TRUE)) %>%
as.data.frame(),
by = c("x" , "y")
) %>%
# remove the pixels that are outside AOI (is.AOI=FALSE)
filter(is.AOI) %>%
# remove the FID and is.AOI columns from the AOI mask
select(-FID , -is.AOI)
# =====================================
# cross validation design: spatial cross validation
# =====================================
# spatially blocked k-fold cross validation
k_fold <- 10
# spatially-blocked by grids across AOI
set.seed(2201)
# make grids and assign cross validation index
spatialGrid_CV <- AOI %>%
# reporject to OMI
st_transform(st_crs(spatial)) %>%
# make grids
st_make_grid(n = c(10,4)) %>%
st_as_sf() %>%
# randomly assign cross validation index
mutate(spatial_CV = sample(1:k_fold , nrow(.) , replace = TRUE))
# rasterize the grids with CV-index to stars
spatialGrid_CV_stars <- st_rasterize(spatialGrid_CV["spatial_CV"], template = spatial) %>%
mutate(spatial_CV = as.factor(spatial_CV))
# visualize
ggplot() +
# spatial-CV
geom_stars(data = spatialGrid_CV_stars) +
# OMI grids
geom_sf(data = spatial %>%
# convert the grids to polygon to visualize the grid cells
st_as_sf(as_points = FALSE) ,
color = "azure1" , fill = NA , alpha = 0.5 , size = 0.2) +
# Switzerland
geom_sf(data = CH , fill = NA , color = "white") +
# AOI
geom_sf(data = AOI , fill = NA , color = "azure2") +
scale_fill_npg() +
coord_sf(expand = FALSE) +
labs(x = "Longtitude" , y = "Latitude" , fill = "k-fold \ncross \nvalidation \ngroup")
# check if the number of OMI pixels in each fold is even
table(pull(spatialGrid_CV_stars))
# include the spatial CV design into the input data
imputation_df <- spatialGrid_CV_stars %>%
setNames("spatial_CV") %>%
as.data.frame() %>%
# join to the input data
right_join(imputation_df , by = c("x" , "y"))
# default: nearest neighbor resampling (CAMS-Reanalysis 0.75˚ downscale to OMI 0.25˚)
CAMS_rsNN <- CAMS_raw %>%
st_warp(dest = OMI_raw)
{ # separate the resampled CAMS data into sub-datasets(8*2=16) to have the same dimension as OMI
subset.CAMS_hour <- CAMS_rsNN %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
# 2 attributes: "tcno2" "tc_no"
subset.CAMS_var <- CAMS_rsNN %>% names()
# subset into 16 3D arrays
for(h in subset.CAMS_hour){
for(v in subset.CAMS_var){
# subset the raw dataset: at hour h and for variable (attribute) v
CAMS_rs_temp <- CAMS_rsNN %>%
filter(hour(time) == h) %>%
select(all_of(v)) %>%
setNames(v) %>%
# dimension: date
st_set_dimensions(3 ,
values = as_date(st_get_dimension_values(. , 3)) ,
names = "date")
# name the object name as CAMS_rs_{Variable}_{Hour}
assign(paste0("CAMS_rs_" , v , "_" , h) , CAMS_rs_temp)
rm(CAMS_rs_temp)
}
}
# clean intermediate objects of the loop
rm(h , v , subset.CAMS_hour , subset.CAMS_var)
}
install.packages("cubelyr")
{ # separate the resampled CAMS data into sub-datasets(8*2=16) to have the same dimension as OMI
subset.CAMS_hour <- CAMS_rsNN %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
# 2 attributes: "tcno2" "tc_no"
subset.CAMS_var <- CAMS_rsNN %>% names()
# subset into 16 3D arrays
for(h in subset.CAMS_hour){
for(v in subset.CAMS_var){
# subset the raw dataset: at hour h and for variable (attribute) v
CAMS_rs_temp <- CAMS_rsNN %>%
filter(hour(time) == h) %>%
select(all_of(v)) %>%
setNames(v) %>%
# dimension: date
st_set_dimensions(3 ,
values = as_date(st_get_dimension_values(. , 3)) ,
names = "date")
# name the object name as CAMS_rs_{Variable}_{Hour}
assign(paste0("CAMS_rs_" , v , "_" , h) , CAMS_rs_temp)
rm(CAMS_rs_temp)
}
}
# clean intermediate objects of the loop
rm(h , v , subset.CAMS_hour , subset.CAMS_var)
}
# 3. ERA5 (downscaling) --------------------------------
# default: nearest neighbor resampling
ERA_rsNN <- ERA_raw %>%
st_warp(dest = OMI_raw)
{ # separate the resampled CAMS data into sub-datasets(8*2=16) to have the same dimension as OMI
subset.ERA_hour <- ERA_rsNN %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
# 7 attributes: "u10" "v10" "t2m" "blh" "sp"  "tcc" "tp"
subset.ERA_var <- ERA_rsNN %>% names()
# subset into 16 3D arrays
for(h in subset.ERA_hour){
for(v in subset.ERA_var){
# subset the raw dataset: at hour h and for variable (attribute) v
ERA_rs_temp <- ERA_rsNN %>%
filter(hour(time) == h) %>%
select(all_of(v)) %>%
setNames(v) %>%
# # dimension: date
st_set_dimensions(3 ,
values = as_date(st_get_dimension_values(. , 3)) ,
names = "date")
# name the object name as ERA_rs_{Variable}_{Hour}
assign(paste0("ERA_rs_" , v , "_" , h) , ERA_rs_temp)
rm(ERA_rs_temp)
}
}
# clean intermediate objects of the loop
rm(h , v , subset.ERA_hour , subset.ERA_var)
}
# convert u,v wind components to wind speed, wind direction
{
subset.ERA_hour <- ERA_raw %>%
st_get_dimension_values(3) %>%
hour() %>%
unique()
for(h in subset.ERA_hour){
ERA_rs_wind_temp <- c(
get(paste0("ERA_rs_u10_" , h)) ,
get(paste0("ERA_rs_v10_" , h))
) %>%
# wd = atan2(-u10,-v10)
# ws = sqrt(u10^2 + v10^2)
transmute(wd = atan2(-u10 , -v10) ,
ws = sqrt(u10^2+v10^2))
# name the object name as CAMS_rs_wind_{Hour}
assign(paste0("ERA_rs_wind_" , h) , ERA_rs_wind_temp)
}
# clean
rm(h , subset.ERA_hour , ERA_rs_wind_temp)
}
# =====================================
# data preparation
# combining spatial and spatialtemporal predictor sets
# =====================================
# spatialtemporal datasets: 3D (x,y,date) + attributes --------------------------------
spatialtemporal <- c(
# OMI
OMI_raw %>%
setNames("OMI_NO2") ,
# CAMS NO2
c(CAMS_rs_tcno2_0 , CAMS_rs_tcno2_3 , CAMS_rs_tcno2_6 , CAMS_rs_tcno2_9 ,
CAMS_rs_tcno2_12 , CAMS_rs_tcno2_15 , CAMS_rs_tcno2_18 , CAMS_rs_tcno2_21) %>%
setNames(c("CAMS_NO2_00" , "CAMS_NO2_03" , "CAMS_NO2_06" , "CAMS_NO2_09" ,
"CAMS_NO2_12" , "CAMS_NO2_15" , "CAMS_NO2_18" , "CAMS_NO2_21")) ,
# CAMS NO
c(CAMS_rs_tc_no_0 , CAMS_rs_tc_no_3 , CAMS_rs_tc_no_6 , CAMS_rs_tc_no_9 ,
CAMS_rs_tc_no_12 , CAMS_rs_tc_no_15 , CAMS_rs_tc_no_18 , CAMS_rs_tc_no_21) %>%
setNames(c("CAMS_NO_00" , "CAMS_NO_03" , "CAMS_NO_06" , "CAMS_NO_09" ,
"CAMS_NO_12" , "CAMS_NO_15" , "CAMS_NO_18" , "CAMS_NO_21")) ,
# ERA blh
c(ERA_rs_blh_0 , ERA_rs_blh_3 , ERA_rs_blh_6 , ERA_rs_blh_9 ,
ERA_rs_blh_12 , ERA_rs_blh_15 , ERA_rs_blh_18 , ERA_rs_blh_21) %>%
setNames(c("blh_00" , "blh_03" , "blh_06" , "blh_09" ,
"blh_12" , "blh_15" , "blh_18" , "blh_21")) ,
# ERA temperature
c(ERA_rs_t2m_0 , ERA_rs_t2m_3 , ERA_rs_t2m_6 , ERA_rs_t2m_9 ,
ERA_rs_t2m_12 , ERA_rs_t2m_15 , ERA_rs_t2m_18 , ERA_rs_t2m_21) %>%
setNames(c("t2m_00" , "t2m_03" , "t2m_06" , "t2m_09" ,
"t2m_12" , "t2m_15" , "t2m_18" , "t2m_21")) ,
# ERA surface pressure
c(ERA_rs_sp_0 , ERA_rs_sp_3 , ERA_rs_sp_6 , ERA_rs_sp_9 ,
ERA_rs_sp_12 , ERA_rs_sp_15 , ERA_rs_sp_18 , ERA_rs_sp_21) %>%
setNames(c("sp_00" , "sp_03" , "sp_06" , "sp_09" ,
"sp_12" , "sp_15" , "sp_18" , "sp_21")) ,
# ERA total cloud cover
c(ERA_rs_tcc_0 , ERA_rs_tcc_3 , ERA_rs_tcc_6 , ERA_rs_tcc_9 ,
ERA_rs_tcc_12 , ERA_rs_tcc_15 , ERA_rs_tcc_18 , ERA_rs_tcc_21) %>%
setNames(c("tcc_00" , "tcc_03" , "tcc_06" , "tcc_09" ,
"tcc_12" , "tcc_15" , "tcc_18" , "tcc_21")) ,
# ERA total precipitation
c(ERA_rs_tp_0 , ERA_rs_tp_3 , ERA_rs_tp_6 , ERA_rs_tp_9 ,
ERA_rs_tp_12 , ERA_rs_tp_15 , ERA_rs_tp_18 , ERA_rs_tp_21) %>%
setNames(c("tp_00" , "tp_03" , "tp_06" , "tp_09" ,
"tp_12" , "tp_15" , "tp_18" , "tp_21")) ,
# ERA wind
c(ERA_rs_wind_0 , ERA_rs_wind_3 , ERA_rs_wind_6 , ERA_rs_wind_9 ,
ERA_rs_wind_12 , ERA_rs_wind_15 , ERA_rs_wind_18 , ERA_rs_wind_21) %>%
setNames(c("wd_00", "ws_00", "wd_03", "ws_03", "wd_06", "ws_06", "wd_09", "ws_09",
"wd_12", "ws_12", "wd_15", "ws_15", "wd_18", "ws_18", "wd_21", "ws_21"))
) %>%
st_set_dimensions(3 , values = yday(st_get_dimension_values(. , 3)) , names = "DOY")
# spatial datasets: 2D (x,y) + attributes --------------------------------
spatial <- c(
# DEM
DEM_rs
)
# input data frame for the imputation model --------------------------------
imputation_df <- spatialtemporal %>%
as.data.frame() %>%
mutate(across(everything() , as.numeric)) %>%
left_join(spatial %>% as.data.frame() ,
by = c("x" , "y")) %>%
# Some pixels are outside of the AOI and are always NA,
# should be removed from the data.frame so that it wouldn’t be counted.
full_join(
# AOI mask in raster form
AOI %>%
st_rasterize(template = spatial) %>%
# is.AOI: a column with TRUE/FALSE
mutate(is.AOI = ifelse(is.na(FID) , FALSE , TRUE)) %>%
as.data.frame(),
by = c("x" , "y")
) %>%
# remove the pixels that are outside AOI (is.AOI=FALSE)
filter(is.AOI) %>%
# remove the FID and is.AOI columns from the AOI mask
select(-FID , -is.AOI)
# =====================================
# cross validation design: spatial cross validation
# =====================================
# spatially blocked k-fold cross validation
k_fold <- 10
# spatially-blocked by grids across AOI
set.seed(2201)
# make grids and assign cross validation index
spatialGrid_CV <- AOI %>%
# reporject to OMI
st_transform(st_crs(spatial)) %>%
# make grids
st_make_grid(n = c(10,4)) %>%
st_as_sf() %>%
# randomly assign cross validation index
mutate(spatial_CV = sample(1:k_fold , nrow(.) , replace = TRUE))
# rasterize the grids with CV-index to stars
spatialGrid_CV_stars <- st_rasterize(spatialGrid_CV["spatial_CV"], template = spatial) %>%
mutate(spatial_CV = as.factor(spatial_CV))
# include the spatial CV design into the input data
imputation_df <- spatialGrid_CV_stars %>%
setNames("spatial_CV") %>%
as.data.frame() %>%
# join to the input data
right_join(imputation_df , by = c("x" , "y"))
# grid search over every combination
N.trees <- 500
# =====================================
# final model
# =====================================
formula_rf_final <- OMI_NO2 ~ CAMS_NO2_15 + CAMS_NO_15 + DEM + DOY + y + x
modelInput_df <- imputation_df %>%
select(x , y , DOY , OMI_NO2 , DEM , ends_with("_15") , spatial_CV) %>%
# exclude rows with missing predictor/response value
filter(!if_any(everything() , is.na))
rf_final <- ranger(formula_rf_final ,
data = modelInput_df ,
num.trees = 1000 ,
mtry = 5 ,
importance = "impurity" ,
keep.inbag = TRUE)
rf_final
rf_final <- ranger(formula_rf_final ,
data = modelInput_df ,
num.trees = 1000 ,
mtry = 5 ,
importance = "impurity" ,
keep.inbag = TRUE)
rf_final
# =====================================
# preduction
# =====================================
# OOB-prediction
rf_final_pred <- rf_final$predictions # OOB-predictions
rf_final_obs_pred <- modelInput_df %>%
select(x,y,DOY,OMI_NO2,spatial_CV) %>%
rename(obs = OMI_NO2) %>%
mutate(pred_OOB = rf_final_pred)
# cross validation prediction
for(k in 1:k_fold){
# model
rf_temp_cv <- ranger(formula_rf_final ,
data = modelInput_df %>%
filter(spatial_CV != as.character(k)) ,
importance = "impurity" ,
keep.inbag = TRUE ,
num.trees = rf_final$num.trees ,
mtry = rf_final$mtry)
# prediction on test set
rf_temp_cv_pred <- modelInput_df %>%
filter(spatial_CV == as.character(k)) %>%
mutate(pred_CV = predict(rf_temp_cv , data = .)$predictions)
# save CV prediction
if(k == 1){
rf_final_obs_pred_cv <- rf_temp_cv_pred
}else{ # append
rf_final_obs_pred_cv <- rf_final_obs_pred_cv %>%
bind_rows(rf_temp_cv_pred) %>%
select(x,y,DOY,OMI_NO2,spatial_CV,pred_CV)
}
# clean
rm(rf_temp_cv , rf_temp_cv_pred)
}
# full-model and CV- prediction
rf_final_obs_pred <- rf_final_obs_pred %>%
inner_join(rf_final_obs_pred_cv , by = c("x" , "y" , "DOY" , "spatial_CV" , "obs"="OMI_NO2"))
# =====================================
# evaluation
# =====================================
rf_final_indices <- rf_final_obs_pred %>%
# pooled OOB-R2, OOB-MAPE, CV-R2, CV-MAPE
summarize(OOB_R2 = cor(obs , pred_OOB)^2 ,
OOB_MAPE = Metrics::mape(obs , pred_OOB) ,
CV_R2 = cor(obs , pred_CV)^2 ,
CV_MAPE = Metrics::mape(obs , pred_CV)) %>%
pivot_longer(cols = everything()) %>%
left_join(
rf_final_obs_pred %>%
# CV-fold specific CV-R2, CV-MAPE
group_by(spatial_CV) %>%
summarize(CV_R2 = cor(obs , pred_CV)^2 ,
CV_MAPE = Metrics::mape(obs , pred_CV)) %>%
ungroup() %>%
pivot_longer(cols = c(CV_R2, CV_MAPE)) %>%
group_by(name) %>%
summarize(min = min(value) ,
max = max(value)) ,
by = "name"
) %>%
bind_rows(
rf_final_obs_pred %>%
pivot_longer(cols = c(pred_OOB , pred_CV) , names_prefix = "pred_" , values_to = "pred" , names_to = "type") %>%
group_by(type) %>%
# slope, intercept
group_modify(~ lm(obs~pred , data = .x) %>% broom::tidy()) %>%
ungroup() %>%
select(type , term , estimate , std.error) %>%
# tidy
rename(name = term , value = estimate) %>%
mutate(name = str_remove_all(name , "[:punct:]") %>% str_to_lower()) %>%
mutate(name = ifelse(name == "pred" , "slope" , name)) %>%
unite(col = "name" , type , name , sep = "_") %>%
# standard error
mutate(min = value - 1.96*std.error ,
max = value + 1.96*std.error) %>%
select(-std.error)
)
rf_final_indices
# visualization: observed <-> predicted
rf_final_obs_pred %>%
pivot_longer(cols = starts_with("pred_") , names_to = "type" , names_prefix = "pred_" , values_to = "pred") %>%
# rename and reorder for visualization
mutate(type = ifelse(type == "OOB" , "Full-model-OOB-prediction" , "CV-prediction") %>%
factor(levels = c("Full-model-OOB-prediction" , "CV-prediction"))) %>%
# visualization
ggplot(aes(x = pred , y = obs)) +
geom_abline(slope = 1 , intercept = 0 , linetype = 2 , color = "azure4") +
ggpointdensity::geom_pointdensity(shape = 1 , alpha = 0.5 , adjust = 3e15) +
geom_smooth(method = "lm") +
scale_color_viridis_c() +
facet_grid(~type) +
coord_fixed(1) +
labs(x = expression("Modeled OMI-NO"[2]) , y = expression("Observed OMI-NO"[2])) +
theme_bw() +
theme(legend.position = "none")
cowplot::save_plot(
filename = "3_results/output-data/imputation-OMI/obs_pred_scatterplot.png" ,
plot = last_plot() ,
base_height = 5 , base_width = 7
)
